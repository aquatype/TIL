# RAIL

[Introducing RAIL: A User-Centric Model For Performance]에서 발췌 요약하여 번역.

번역해놓고 보니 음… 그냥 실무에서 보편적으로 고려하는 UX의 골든룰을 정형화해놓은 거에 지나지 않는 것 같긴 하다. 다만 일반적인 퍼포먼스 최적화 방식과는 다르게 철저하게 유저를 중심에 놓고 거기에 맞춘 threshold를 설정한다는 게 인상깊은 점.

### RAIL은:

* 구글 크롬 팀에서 퍼포먼스의 정의를 ‘유저’ 중심으로 개편하면서 창시한 UX 모델임
* 유저 경험을 키 액션(탭, 드래그, 스크롤, 로드 등)로 쪼개어 정의함
* 그러한 키 액션에 대한 퍼포먼스 골을 제공함. 예를 들면 탭에서 페인트까지 100ms 이하라던지.
* ‘퍼포먼스’에 대한 (일관성있는) 개념적 구조를 제공하여, 디자이너와 개발자가 가장 효율적인 방법을 선택할 수 있도록 도와줌
* 일반적인 유저 인터렉션을 분석해보면 유저가 하는 행동을 **로드하고(Load) / 애니메이션을 보고(Animation) / 잠깐 멍때리다가(Idle) / 기능을 사용하는(Response)** 4가지로 크게 나눌 수 있는데, 이 이니셜을 딴 게 RAIL임

#### 1. Response

버튼을 클릭했다 치면, 앱은 유저가 랙을 느끼기 전에 거기에 대한 반응을 해야 한다. 이게 유의미한 시간 내에 되지 않으면 액션-리액션 사이의 체인이 깨져버린다. Response에서 중요한 건 지연시간latency다. 응답이 너무 늦으면 이게 과연 내가 클릭한 걸 알아먹긴 했나 생각하게 되잖아? 그게 안되는 거라고.

Response의 주된 인터렉션은 ‘누르는 거’다. 버튼이든 아이콘이든. 여기에 반응형으로 응답을 하려면 a. 일단 피드백이 100ms 이하의 시간 내에 떠야 하고, b. 그 피드백이 유저가 원하는 내용을 담고 있는 것이 이상적이다. 만약 로딩이 길어지게 되면 로딩 인디케이터나 버튼에 액티브 컬러 등을 넣어도 된다. 어쨌거나 유저가 내가 입력을 제대로 했는지 의문을 갖지 않게 만드는 게 핵심이다.

#### 2. Animation

애니메이션은 다음을 포함한다:

* 비주얼 애니메이션. 시작과 종료 애니메이션, 트위닝, 로딩 인디케이터 등
* 스크롤링. 유저가 스크롤을 시작하고, 놓았을 때, 페이지가 흘러내려가는 것을 말함
* 드래그. 유저의 드래그 인터렉션에 100ms 이하로 반응하기 위해서는 애니메이션이 필요함

애니메이션을 제대로 수행하려면, 60FPS 기준으로 매 프레임은 16ms보다 적은 시간에 수행되어야 한다.

#### 3. Idle

[Optimistic UI 패턴]을 참고. 완료가 되어야 하는 작업 중에는 ‘response’나 ‘load’를 배제하면 critical time window 내에서 실행될 필요가 없는 것들이 많다. 부트스트래핑, 컴포넌트 이니셜라이징, 검색과 정렬, 통계데이터 전송 등은 브라우저가 대기 상태일 때 처리해도 상관없는 것들이다.

대기 시간을 현명하게 사용하기 위해서는, 이런 작업들을 50ms 이내로 수행 가능한 블럭 단위로 모듈화하는 것이 좋다. 사용자가 인터렉션을 시작하면 100ms 이내에 응답을 해줘야 하니까.

#### 4. Load

페이지 로딩이야말로 꾸준히 발전해 온 퍼포먼스 해킹의 핵심이며, 유저에게 유의미한 first paint를 빨리 보여주는 것이 중점이다. 그 이후엔, 앱은 유저가 사용함에 있어 어떠한 장애도 없도록 responsive한 상태를 유지해야만 한다.

1초 이전에 meaningful first paint를 발생시키는 것이 목표이며, 이보다 길어질 경우 사용자의 관심은 우주로 가기 시작하고 앱에 대한 집중도가 떨어지게 된다. 크리티컬 렌더링 패스를 구축하고, Idle 시간에 지연 로딩deferred loading을 수행하거나 아예 온디맨드로 구현하는 등의 방법론이 수반된다.

### ‘느리다’

* 절대적으로 느린 프로세스는 없음. 컨텍스트에 따라 상대적인 것이고, 중요한 건 그 컨텍스트마다 유저가 기대하는 성능 기대치가 전부 다르다는 것임.
* 구글의 #1 철칙: “유저에 집중하면 나머지는 알아서 따라온다”
* ‘느린가?’ 대신 ‘유저가 쓸 때 어떤 느낌을 받을까?’를 고려할 것

### 유저 경험

20년 전부터 업계 정석인 [연구 결과]에 요즘 대세인 애니메이션에 대한 내용을 쪼끔 섞어서, 구글에서는 다음과 같은 threshold를 설정해두고 있다:

* 100ms 이내: 유저는 ‘즉시’로 인지한다. 이보다 길면 액션과 리액션 사이의 연결성이 희미해진다.
* 1초 이내: ‘작업의 자연스럽고 연속적인 진행’으로 인지한다. 이보다 길면 유저는 그들이 하고 있던 작업에 대한 포커스를 잃어버린다. 페이지 로드를 생각하면 됨.
* 16ms: 닌겐의 눈은 동작 추적에 특히 뛰어나기 때문에, 주사율 문제든 랙이 걸리든 해서 모션에 대한 기대치가 충족되지 않으면 부정적인 경험으로 인식한다.


### Reference:

 * [Introducing RAIL: A User-Centric Model For Performance] (Paul Irish & Paul Lewis)

[Introducing RAIL: A User-Centric Model For Performance]:https://www.smashingmagazine.com/2015/10/rail-user-centric-model-performance/
[연구 결과]:https://www.nngroup.com/articles/response-times-3-important-limits/
[Optimistic UI 패턴]:http://info.meteor.com/blog/optimistic-ui-with-meteor-latency-compensation